import tetrigeddon.TileGrid;
import tetrigeddon.EnemyManager;
import tetrigeddon.Enemy;
import tetrigeddon.display.Debris;
import tetrigeddon.Score;
import mx.utils.Delegate;
/**
* Manipulates the entire game world.
* @author Daniel J Lawhead
* @version 1.0.0
* @since 0.0.7
*/
class Game
{
	/**
	* Grid of TileBlocks represented as numbers.
	*/
	public static var tileGrid:TileGrid;
	/**
	* Current level the game is in.
	*/
	private static var level:Number;
	/**
	* Manages Enemy instances.
	*/
	public static var enemies:EnemyManager;
	
	/**
	 * Player's score.
	 */
	public static var playerScore:Score;
	
	/**
	 * ID generated by setInterval for moving the current figure down.
	 */
	private static var progressGameIntr:Number;
	
	/**
	 * ID generated by setInterval for shaking a MovieClip.
	 */
	private static var shakeIntr:Number;
	
	/**
	 * Contains city assets to destroy when blocks shake the screen.
	 */
	private static var cityArray:Array;
	
	/*
	 * Records when the next level occures.
	 */
	private static var nextLvl:Number;

	/**
	* Manages the entire game.
	*/
	public static function init():Void
	{
		_root.stop();

		// Define global variables.
		_global.score = 0;
		_global.NUM_BLOCKS_X = 23;
		_global.GRID_START_X = 7;
		_global.GRID_END_X = 15;
		_global.NUM_BLOCKS_Y = 16;
		_global.NUM_BLOCK_GRAPHICS = 34;
		_global.BLOCK_SIZE = 35;
		_global.BLOCK_SPACING = 1;
		_global.SCREEN_WIDTH = 800;
		_global.SCREEN_HEIGHT = 600;

		Game.tileGrid = new TileGrid();
		
		Game.playerScore = new Score();
		
		_root.mainAudioLoopStarted = false;
		_root.spaceUp = true;
		_root.onKeyUp = function()
		{
			switch (Key.getCode())
			{
				case Key.SPACE : 
					_root.spaceUp = true;
					break;
			}
		}
		_root.onKeyDown = function()
		{
			switch (Key.getCode())
			{
				case Key.LEFT : 
					if (Game.tileGrid.move("left", true))
					{
						Game.tileGrid.move("left", false);
					}
					break;
				case Key.RIGHT :
					if (Game.tileGrid.move("right", true))
					{
						Game.tileGrid.move("right", false);
					}
					break;
				case Key.UP : 
					if (Game.tileGrid.rotate(true))
					{
						Game.tileGrid.rotate(false);
					}
					break;
				case Key.DOWN :
					if (Game.tileGrid.move("down", true))
					{
						Game.tileGrid.move("down", false);
					}
					break;					
				case Key.SPACE :
					if (_root.spaceUp)
					{
						Game.tileGrid.drop();
						_root.spaceUp = false;
						break;
					}
			}
		};
		Key.addListener(_root);

		Game.shakeIntr = -1;
		
		Game.cityArray = new Array(_root.mc_roof1, _root.mc_window1, _root.mc_window1_, _root.mc_window1__, _root.mc_roof2, _root.mc_roof2_, _root.mc_roof2__, _root.mc_building1, _root.mc_window2._root.mc_1, _root.mc_window2._root.mc_2, _root.mc_window2_2._root.mc_1, _root.mc_window2_2._root.mc_2, _root.mc_door1, _root.mc_roof3, _root.mc_roof3_, _root.mc_window3, _root.mc_window4._root.mc_1, _root.mc_window4._root.mc_2, _root.mc_window6._root.mc_1, _root.mc_window6._root.mc_2, _root.mc_door2, _root.mc_building2, _root.mc_building3, _root.mc_roof4, _root.mc_building6, _root.mc_window5, _root.mc_window7._root.mc_1, _root.mc_window7._root.mc_2, _root.mc_window8._root.mc_1, _root.mc_window8._root.mc_2, _root.mc_window9._root.mc_1, _root.mc_window9._root.mc_2, _root.mc_stairs, _root.mc_building5, _root.mc_building6, _root.mc_building7, _root.mc_window10, _root.mc_window11, _root.mc_window12, _root.mc_window13, _root.mc_window14, _root.mc_window15, _root.mc_window16, _root.mc_window17, _root.mc_window18, _root.mc_window19, _root.mc_window20, _root.mc_window21, _root.mc_tree1._root.mc_1, _root.mc_tree1._root.mc_2, _root.mc_tree1._root.mc_3, _root.mc_tree2._root.mc_1, _root.mc_tree2._root.mc_2, _root.mc_tree2._root.mc_3, _root.mc_tree3._root.mc_1, _root.mc_tree3._root.mc_2, _root.mc_tree3._root.mc_3, _root.mc_tree4._root.mc_1, _root.mc_tree4._root.mc_2, _root.mc_tree4._root.mc_3, _root.mc_sidewalk, _root.mc_cityscape, _root.mc_cityscape2, _root.mc_mountain, _root.mc_sky, _root.mc_clouds, _root.mc_chaos, _root.mc_chaos2);
		tileGrid.create();
		tileGrid.createNewFigure();
		Game.nextLvl = 0;
		_root.mc_cityscape.ox = _root.mc_cityscape._x;
		_root.mc_cityscape.oy = _root.mc_cityscape._y;
		_root.mc_cityscape2.ox = _root.mc_cityscape2._x;
		_root.mc_cityscape2.oy = _root.mc_cityscape2._y;
		// Start the game!!
		Game.start();
	}
	
	public static function start():Void
	{
		Game.level = 1;
		Game.enemies = new EnemyManager();
		Game.tileGrid.downSpeed = 700;
		Game.progressGameIntr = setInterval(tileGrid, "progressGame", Game.tileGrid.downSpeed);
		Game.enemies.max = 10;
		_root.onEnterFrame = function ()
		{
			_root.score_txt.text = _root.scoreShadow_txt.text = Game.playerScore.getScore();
			Game.loop();
		}
	}
	
	public static function stop():Void
	{
		trace("<<Game::stop>> Called.");
		Game.tileGrid.destroy();
		Game.enemies.clear();
		_root.mainAudioLoopStarted = false;
		for (var i:String in _root) {
			if (i.indexOf("debris_") > -1 || i.indexOf("bird_") > -1 || i.indexOf("citizen_") > -1) {
				_root[i].removeMovieClip();
			}
		}
		clearInterval(Game.progressGameIntr);
		delete Game.enemies;
		delete Game.tileGrid;
		delete _root.onEnterFrame;
		delete _root.onKeyDown;
	}
	
	/**
	* Iterates through the game loop once.
	*/
	private static function loop():Void
	{
		Game.nextLvl = Game.playerScore.getScore() - (Game.level * 3500);
		if (Game.nextLvl > 0)
		{
			Game.level += 1;
			// Destroy background
			Game.shake(_root.shake);
			destroyScenery();
		}
		Game.enemies.addEnemy(Game.randomNumber(1, 2));
		Game.enemies.update();
	}
	
	/**
	* Shakes screen. DEPRECATED!
	*/
	public static function shakeScreen():Void
	{
		// Check if screen is already shaking.
		if (_root.tempShakeMC != undefined)
		{
			delete _root.tempShakeMC.onEnterFrame;
			_root.tempShakeMC.removeMovieClip();
		}
		var tempShakeMC:MovieClip = _root.createEmptyMovieClip("tempShakeMC", _root.getNextHighestDepth());
		tempShakeMC.pointY = 0;
		// I set predefined X/Y coords to where the screen should bounce.
		_root._y += 10;
		tempShakeMC.distY = _root._y - 15;
		// Set inertia and spring.
		tempShakeMC.inertia = 0.9; // Set to 1 will oscillate forever.
		tempShakeMC.spring = 2;
		// Set amount which to shake screen by.
		tempShakeMC.amount = Math.floor(Math.random() * (20 - 5 + 1)) + 5;
		tempShakeMC.onEnterFrame = function ()
		{
			var distY:Number = -_root._y + this.amount;
			// Calculate amount by which screen should move.
			this.pointY = this.pointY * this.inertia + distY * this.spring;
			// Move screen.
			var oldY:Number = _root._y;
			_root._y += this.pointY;
			// Check if MC should remove itself.
			if (oldY == _root._y)
			{
				this.removeMovieClip();
			}
		}
	}
	
	public static function randomNumber(min:Number, max:Number):Number
	{
		return Math.floor(Math.random() * (max - min + 1)) + min;
	}
	
	public static function resetSpeed():Void
	{
		clearInterval(Game.progressGameIntr);
		Game.tileGrid.downSpeed = Game.randomNumber(100, 500);
		Game.progressGameIntr = setInterval(tileGrid, "progressGame", Game.tileGrid.downSpeed);
	}
	
	/**
	 * Shakes a movieclip.
	 */
	public static function shake(mc:MovieClip, multiplier:Number):Void {
		if (Game.shakeIntr != -1) return;
		if (multiplier == undefined) multiplier = 1;
		// Original values of MovieClip.
		var origVals:Array = [mc._x, mc._y];
		// Keeps track of how many times shakemc was called.
		var counter:Number = 0;
		var shakemc:Function = function ()
		{
			mc._x = origVals[0];
			mc._y = origVals[1];
			// Check if shaking should stop!
			if (++counter > 5)
			{
				clearInterval(Game.shakeIntr);
				Game.shakeIntr = -1;
				return;
			}
			
			mc._x += Game.randomNumber(-6 * multiplier, 6 * multiplier);
			mc._y += Game.randomNumber(-6 * multiplier, 6 * multiplier);
		}
		// Begin shaking only if mc is not already shaking.
		Game.shakeIntr = setInterval(shakemc, 10);
		/*
		for (var i:Number = 0; i != _root.cityArray.length; i++)
		{
			_root.cityArray[i].gotoAndStop(_root.cityArray[i]._currentframe + 1);
		}
		*/
	}
	private static function destroyScenery() {
		for (var i:Number = 0; i < Game.cityArray.length; i++) {
			Game.cityArray[i].gotoAndStop(cityArray[i]._currentframe+1);
		}
	}
}
