package tetrigeddon {		/**	* An enemy that interacts with the player's block stack.	*/		import flash.display.MovieClip;	import tetrigeddon.display.ComicBubble;	import flash.events.Event;		public class Enemy	{		/**		* UID assinged to Enemy by EnemyManager.		*/		public var id:Number;				/**		* Graphical representation of Enemy.		*/		public var movieClip:MovieClip;				/**		* State of the enemy.		*/		public var state:Number;				/**		* Current horizontal position in grid units.		*/		public var _curX:Number;				/**		 * Current vertical position in grid units.		 */		public var _curY:Number;				/**		* Different Enemy states.		*/		public var states:Object;				/**		* Direction enemy is facing.		*/		public var dir:Number;				/**		* Minimum distance enemy may travel vertically		*/		public var groundRow:Number;				/**		 * Score recieved by killing this enemy.		 */		public var _score:Number;				/**		 * Sound attached when enemy dies.		 */		public var deathSound:String;				/**		* The main timeline		*/		public var _mainTimeline:MovieClip;						/**		* Basic enemy which slowly walks back and forth.		*/		public function Enemy()//__mainTimeline:MovieClip)		{									this.states = new Object();			this.states.dead = -1;			this.states.idle = 0;						this.groundRow = this.y = 15; // Floor. Concrete.						this._curX = 0;			this._curY = 0;									this._score = 0;			this.deathSound = "line" + Game.randomNumber(1, 28)		}				/**		* Gets current horizontal position in grid units.		* @return	Horizontal position in grid units.		*/		public function get x():Number		{			return this._curX;		}				/**		* Sets current horizontal position in grid units.		* @param	n	New horizontal position in grid units.		*/		public function set x(n:Number)		{			this._curX = n;			//this.movieClip.x = Math.floor(this._curX * (_mainTimeline.BLOCK_SIZE + _mainTimeline.BLOCK_SPACING)); //(35 + 1)); //			try{				this.movieClip.x = Math.floor(this._curX * (_mainTimeline.BLOCK_SIZE + _mainTimeline.BLOCK_SPACING));			}catch(e:Error){				//null			}		}				/**		* Gets current vertical position in grid units.		* @return	Vertical position in grid units.		*/		public function get y():Number		{			return this._curY;		}				/**		* Sets current vertical position in grid units.		* @param	n	New vertical position in grid units.		*/		public function set y(n:Number)		{			this._curY = n;			try{				this.movieClip.y = Math.floor(this._curY * (_mainTimeline.BLOCK_SIZE + _mainTimeline.BLOCK_SPACING));/**/			}catch(e:Error){				//null			}		}				/**		* Returns current X position in pixels.		* @return	Current X position.		*/		public function get pixelX():Number		{			try{				return this.movieClip.x;			}catch(e:Error){				//null			}		}				/**		* Sets current X position.		* @param	n	New X position in pixels.		*/		public function set pixelX(n:Number)		{			try{				this.movieClip.x = n;				this._curX = Math.floor(this.movieClip.x / (_mainTimeline.BLOCK_SIZE + _mainTimeline.BLOCK_SPACING));			}catch(e:Error){				//null			}		}				/**		* Returns current Y position in pixels.		* @return	Current Y position.		*/		public function get pixelY():Number		{			//trace("get pixelY(); called");			try{				return this.movieClip.y;			}catch(e:Error){				//null			}		}				/**		* Sets current Y position.		* @param	n	Y position in pixels.		*/		public function set pixelY(n:Number)		{			//trace("set pixelY("+n+"); called");			try{				this.movieClip.y = n;				this._curY = Math.floor(this.movieClip.y / (_mainTimeline.BLOCK_SIZE + _mainTimeline.BLOCK_SPACING));			}catch(e:Error){				//null			}		}				/**		 * Tiggers collision check, updates state, toggles appropriate animation and movement.		 */		/*public function update()		{			throw new Error("<<Enemy.update()>> Requires implementation before use!!");		}*/				/**		 * Gets points this enemy is worth.		 * @returns Scoring points of enemy.		 */		public function get score():Number		{			return _score;		}				public function die(movieClip:Object, timeline:Object) //movieClip = this.movieClip - timeline = this._mainTimeline		{			//trace("Enemy.die();");			var removeCnt:Number = 0;			var removeOn:Number = 160; //160 is about the length of the longest death animation			//			this.state = this.states.dead;			Game.playerScore.addScore(this.score);			if(Game.randomNumber(100, 0) > 60){				var b:ComicBubble = new ComicBubble(pixelX + Game.randomNumber(-10, 10), pixelY - Game.randomNumber(50, 80), "onomatopoeia", this._mainTimeline);			};			if (Game.randomNumber(1, 2) == 2 && !_mainTimeline.startedCommentary) {				_mainTimeline.mc_commentary.gotoAndPlay(this.deathSound);				_mainTimeline.mc_commentaryani.play();				_mainTimeline.startedCommentary = true;			}			//remove it after countdown			//used to fade out then remove			function _onEnterFrame(event:Event){				removeCnt++;				if(removeCnt>=removeOn){					movieClip.removeEventListener(Event.ENTER_FRAME, _onEnterFrame);					movieClip.removeEventListener(Event.REMOVED_FROM_STAGE, _onRemoved);					//					//trace("Remove: "+movieClip+" from timeline: "+timeline);					timeline.removeChild(movieClip);				}			}			function _onRemoved(event:Event){				//to clear the ENTER_FRAME incase the movieclip is removed				movieClip.removeEventListener(Event.ENTER_FRAME, _onEnterFrame);				movieClip.removeEventListener(Event.REMOVED_FROM_STAGE, _onRemoved);			}			//add the above listeners			movieClip.addEventListener(Event.ENTER_FRAME, _onEnterFrame);			movieClip.addEventListener(Event.REMOVED_FROM_STAGE, _onRemoved);			//			if (_mainTimeline.mainAudioLoopStarted == false && this.toString()!="[object Bird]") {				_mainTimeline.chan_menuLoop.stop();				_mainTimeline.chan_game_loop = _mainTimeline.snd_game_loop.play(0,int.MAX_VALUE);				_mainTimeline.mainAudioLoopStarted = true;			}			Game.enemies.removeEnemy(this);		}	}}