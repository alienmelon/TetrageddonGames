package tetrigeddon.enemies {import tetrigeddon.Enemy;import tetrigeddon.display.Debris;import flash.display.*;import flash.utils.*;/** * A 35 by 70 pixels human that attacks tiles, but does no harm to them. */public class Citizen extends Enemy{		public var walkSpeed:Number;		public var dire:Number;		public var aggressive:Boolean;		public var agile:Boolean;		public var jumpIDs:Array;		public var attackID:Number;		public var jumpSpeed:Number;		public var climbSpeed:Number;				public function Citizen(__mainTimeline:MovieClip)		{			//trace("Citizen("+__mainTimeline+"); called.");			super();			this._mainTimeline = __mainTimeline;			this.walkSpeed = Game.randomNumber(2, 4);			this.states.walk = 1;			this.states.turn = 2;			this.states.attack = 3;			this.states.climb = 4;			this.states.jump = 5;			this.states.fall = 6;			//Attach the citizen			var sym:String = "citizen" + Game.randomNumber(1, 7);//6);			var citizen:Class = getDefinitionByName(sym) as Class;			this.movieClip = new citizen();			this._mainTimeline.addChild(this.movieClip);			this.movieClip.name = "citizen_" + this.id;			this.movieClip.stop();			//			this._mainTimeline.ARR_ENEMIES.push(this.movieClip);//			var sym:String = "citizen" + Game.randomNumber(1, 6);//			this.movieClip = _root.attachMovie(sym, "citizen_" + this.id, _root.getNextHighestDepth());			this.movieClip.cacheAsBitmap = true;			this.movieClip.enabled = false;  			this.movieClip.buttonMode = false;  			this.movieClip.mouseChildren = false;			this.x = Game.randomNumber(this.x, -10);			this.y = this.groundRow;			this.dire = 1;			this.attackID = -1;			this._score = 300;			if (Game.randomNumber(1, 2) == 1)			{				this.dire = -1;				this.x = Game.randomNumber(25, 28);				//this.x = Game.randomNumber(20, 23);			}			if (Game.randomNumber(0, 3) == 3)			{				this.aggressive = true;			}			if (Game.randomNumber(0, 3) == 3)			{				this.agile = true;			}			this.jumpIDs = new Array();			this._score = 100;			//			switch (sym) {				case "citizen1":					jumpSpeed = 1200;					climbSpeed = 1500;					break;				case "citizen2" : 					jumpSpeed = 1200;					climbSpeed = 1500;				case "citizen3":					jumpSpeed = 800;					climbSpeed = 1800;					break;				case "citizen4":					jumpSpeed = 1000;					climbSpeed = 1200;					break;				case "citizen5":					jumpSpeed = 1000;					climbSpeed = 1000;					break;				case "citizen6":					jumpSpeed = 800;					climbSpeed = 1000;					break;				case "citizen7":					jumpSpeed = 500;					climbSpeed = 1100;					this.walkSpeed = Game.randomNumber(0.5, 1);					this.deathSound = "line29";					break;			}			this.state = this.states.walk;		}				/**		 * Checks for possible collisions, and updates state & animation.		 * @see	EnemyManager.update()		 */		public function update()		{			if(_mainTimeline.stopGame){				this._mainTimeline.removeChild(this.movieClip);				Game.enemies.removeEnemy(this);				//				for (var c:Number = 0; c != this.jumpIDs.length; c++)				{						clearInterval(this.jumpIDs[c]);				}			}			//trace("Citizen.update() called.");			// Check if update should be skipped.			if (this.state == this.states.dead)			{				trace("Citizen.update - this.state == this.states.dead");				this._mainTimeline.removeChild(this.movieClip);				//				Game.enemies.removeEnemy(this);				//				return;			}			// Set initial state.			this.state = this.states.walk;			// Die			if (Game.tileGrid.grid[this.y - 1][this.x] > 0 || Game.tileGrid.grid[this.y][this.x] > 0)			{				//trace("Citizen.update - citizen should die with gibs.");				var d:Debris = new Debris(_mainTimeline);				d.symbol = "gibs";				d.spawn(Game.randomNumber(this.pixelX, this.pixelX + (Math.floor(Math.random() * 5))), this.pixelY, 1, "gibs");				this.movieClip.gotoAndStop("die");				this.die(this.movieClip, this._mainTimeline);				return;			}			// Reached end of screen.			if (this.x < -10 || this.x > 25)			{				//trace("Citizen.update - reached end of screen, Game.enemies.removeEnemy(this) called");				//remove then call removeEnemy				this._mainTimeline.removeChild(this.movieClip);				//				Game.enemies.removeEnemy(this);				return;			}			// Check what direction should sprite scale to.			if (dire == -1)			{				this.movieClip.scaleX = -1;				//this.movieClip._xscale = -100;			} 			else if (dire == 1)			{				this.movieClip.scaleX = 1;				//this.movieClip._xscale = 100;			}			// Check if citizen can walk around!			if ((Game.tileGrid.grid[this.y][this.x + this.dire] <= 0 && Game.tileGrid.grid[this.y - 1][this.x + this.dire] <= 0) || (Game.tileGrid.grid[this.y][this.x + this.dire] == undefined && Game.tileGrid.grid[this.y - 1][this.x + this.dire] == undefined))			{				//trace("Citizen.update - check if citizen can walk around.");				this.state = this.states.walk;				this.movieClip.gotoAndStop("walk");				walk();				}			else if (Game.tileGrid.grid[this.y - 1][this.x + this.dire] == 0 && Game.tileGrid.grid[this.y - 2][this.x + this.dire] == 0 && this.agile)			{				/*trace("Citizen.update - check if citizen can jump over obstruction");*/				// Check if citizen can jump over the obstruction. Citizens can only jump over one block.				this.state = this.states.jump;				this.movieClip.gotoAndStop("jump");				this.jumpIDs.push(setInterval(this.position, jumpSpeed, [this.x + this.dire, this.y - 1]));			}			else if (Game.tileGrid.grid[this.y - 2][this.x + this.dire] == 0 && Game.tileGrid.grid[this.y - 3][this.x + this.dire] == 0 && Game.tileGrid.grid[this.y - 1][this.x] && Game.tileGrid.grid[this.y - 2][this.x] && this.agile)			{				// Can citizen climb over obstruction?				/*trace("Citizen.update - can citizen climp over obstruction.");*/				this.state = this.states.climb;				this.movieClip.gotoAndStop("climb");				this.jumpIDs.push(setInterval(this.position, climbSpeed, [this.x + this.dire, this.y - 2]));			}			else if (this.aggressive)			{				// Aggressive citizen				/*trace("Citizen.update - agressive citizen");*/				this.state = this.states.attack;				this.movieClip.gotoAndStop("attack");				//if (this.attackID == -1) this.attackID = setInterval(this, "destroyBlock", Game.randomNumber(3000, 5000));				if (this.attackID == -1){					this.attackID = setInterval(this.destroyBlock, Game.randomNumber(3000, 5000));					_mainTimeline.ARR_INTERVALS.push(this.attackID);				};			}			// No where to go! OH GOD!			else if ((Game.tileGrid.grid[this.y - 1][this.x - this.dire] > 0 || Game.tileGrid.grid[this.y - 2][this.x - this.dire] > 0) && !this.aggressive && !this.agile)			{				//trace("Citizen.update - No where to go - idle");				this.state = this.states.idle;				this.movieClip.gotoAndStop("idle");			}			else			{				// Turn around.				//trace("Citizen.update - turn arround");				this.dire *= -1;				this.state = this.states.turn;			}			// Should citizen fall?			//if citizen crawled over obstacle, and passed it, fall back to ground level			if (Game.tileGrid.grid[this.y + 1][this.x] == 0 || (Game.tileGrid.grid[this.y + 1][this.x] == undefined && this.y < this.groundRow)){				this.state = this.states.fall;				this.y++;				return;			}		}				/*		 * Moves Citizen according to walking algorithm.		 */		private function walk()		{			//trace("Citizen.walk(); called");			this.pixelX += this.walkSpeed * this.dire;		}				/*		 * Sets citizen's position to specified coordinates, <b>disregard of whether a block is there or not</b>. State is then set to 42 to kick off the update process. Used for positioning sprite after a jump or climb animation played through.		 * @param	pos	New coordinates. Indices 0 and 1 should be set to desired X and Y coordinates respectively.		 */		private function position(pos:Array)		{			/*trace("Citizen.position("+pos+"); called");*/			if (this.state == this.states.jump || this.state == this.states.climb) {				this.x = pos[0];				this.y = pos[1];			}			for (var i:Number = 0; i != this.jumpIDs.length; i++)			{				clearInterval(this.jumpIDs[i]);			}			/*updateAfterEvent();*/			// Reset state.			//this.state = this.states.walk;		}				/*		 * Moves Citizen according to falling algorithm.		 */		private function fall()		{			/*trace("Citizen.fall() called");*/			if (this.y < this.groundRow && Game.tileGrid.grid[this.y + 1][this.x] == 0) 				this.y++;			else				this.state = this.states.walk;		}				/*		 * Destroys block directly infront of Citizen.		 */		private function destroyBlock()		{			//trace("destroy Block");			clearInterval(this.attackID);			this.attackID = -1;			//			if(_mainTimeline.stopGame){				clearInterval(this.attackID);			}			//			if (this.state != this.states.attack) return;			if (Game.tileGrid.grid[this.y - 1][this.x + this.dire] > 0) {				Game.tileGrid.grid[this.y - 1][this.x + this.dire] = 0;				Game.tileGrid.draw();				var d_1:Debris = new Debris(_mainTimeline);				d_1.symbol = "rubble";				d_1.spawn(this.pixelX +(_mainTimeline.BLOCK_SIZE * this.dire), this.pixelY - _mainTimeline.BLOCK_SIZE, 4, "rubble");			} else if (Game.tileGrid.grid[this.y][this.x + this.dire] > 0) {				Game.tileGrid.grid[this.y][this.x + this.dire] = 0;				Game.tileGrid.draw();				var d_2:Debris = new Debris(_mainTimeline);				d_2.symbol = "rubble";				d_2.spawn(this.pixelX +(_mainTimeline.BLOCK_SIZE * this.dire), this.pixelY, 4, "rubble");			}		}	}}