package tetrigeddon {	import flash.display.*;	import flash.events.*;	import flash.utils.*;	import tetrigeddon.TileFigure;	import tetrigeddon.TileBlock;	import tetrigeddon.display.Debris;	/** 	Defines the main game grid where all the blocks are stored.	*/	public class TileGrid 	{			public var timer:Number;			public var lastTime:Number;			public var gameState:String;			public var fullLine:Number;			public var downSpeed:Number;			public var grid:Array;			public var gridTiles:Array;			public var currentFigure:TileFigure;			public var _mainTimeline:MovieClip			//bellow this point all was private			public var dropInterval:Number;			public var forcedDrop:Boolean;			public var parentMC:MovieClip;			public var animateInterval:Number;						public function TileGrid(__mainTimeline:MovieClip)			{				//trace("TileGrid(__mainTimeline) setting default values called");				this.gameState = "normal";				this.fullLine = -1;				this.lastTime = 0;				this.forcedDrop = false;				this._mainTimeline = __mainTimeline;			}						public function create(pmc:MovieClip)			{				//trace("TileGrid.create(pmc) called. root is: "+_mainTimeline);				//if (pmc == undefined) 				if (pmc == null) 					this.parentMC = _mainTimeline;//MovieClip(root); 				else 					this.parentMC = pmc;								//				this.grid = new Array();				this.gridTiles = new Array();				//				for (var i:Number = 0; i < _mainTimeline.NUM_BLOCKS_Y; i++)				{					this.grid.push(new Array());					//					for (var j:Number = 0; j < _mainTimeline.NUM_BLOCKS_X; j++)					{						//this.grid[i][j] = undefined;						this.grid[i][j] = null;//undefined;						//						if (j >= _mainTimeline.GRID_START_X && j <= _mainTimeline.GRID_END_X)						{							//if you see a grid, then it works							this.grid[i][j] = 0;							//							////trace("create(pmc): "+this.grid[i][j]);							//							var mc:MovieClip = new blocks();							this.parentMC.addChild(mc);							mc.name = "block" + i + "_" + j;							mc.cacheAsBitmap = true;							mc.x = j * _mainTimeline.BLOCK_SIZE + _mainTimeline.BLOCK_SPACING;							mc.y = i * _mainTimeline.BLOCK_SIZE + _mainTimeline.BLOCK_SPACING;							mc.gotoAndStop(1);							mc.enabled = false;  							mc.buttonMode = false;  							mc.mouseChildren = false;														gridTiles.push(mc);						}					}				}			}			public function destroy()			{				trace("TileGrid.destroy() called");				//				clearInterval(dropInterval);				clearInterval(animateInterval);				//				for (var i:Number = 0; i<gridTiles.length; i++){					this.parentMC.removeChild(gridTiles[i]);				}				gridTiles = [];/*				for (var i:Number = 0; i < _mainTimeline.NUM_BLOCKS_Y; i++)				{					for (var j:Number = 0; j < _mainTimeline.NUM_BLOCKS_X; j++)					{						var mc:MovieClip = this.parentMC.getChildByName("block" + i + "_" + j) as MovieClip;						this.parentMC.removeChild(mc);						//this.parentMC["block" + i + "_" + j].removeMovieClip();					}				}*/				//				//delete this.grid;				//delete this.currentFigure;				this.grid = null;				this.currentFigure = null;			}						// Moves this.currentFigure down, checks if it "dropped," removes it, checks for full 			// rows, removes full rows, triggers all other lines to shift down, 			// and creates a new random figure.			public function progressGame()			{				//trace("tileGrid.progressGame called as setInterval.");				//remove itself if game should clear/is stopped				if(_mainTimeline.stopGame){					Game.clearGameIntervals();				}				// Check if game is paused.				if (this.gameState == "paused" || this.gameState == "stacked") // || this.gameState == "dropping")				{					//trace("progressGame paused || stacked");					return;				}				else if (this.gameState == "normal")				{					//trace("progressGame normal");					var currentTime:Number = getTimer();					//if (currentTime - this.lastTime >= this.downSpeed || this.forcedDrop)					if (currentTime - this.lastTime >= this.downSpeed)					{						// Check if block dropped.						if (move("down", true) == false)						{							//trace("progressGame down");							this.forcedDrop = false;							// Set all blocks in current figure to be safe for enemies to interact with.							try{								for (var i:Number = 0; i != this.currentFigure.blocks.length; i++)								{									//this will error out because isPlayerBlock is not yet ported over...									this.currentFigure.blocks[i].isPlayerBlock = false;								}							}catch(e:Error){								////trace("TypeError: Error #1009 in  for (var i:Number = 0; i != this.currentFigure.blocks.length; i++)");							}							// Check if any block stacked to top of grid.							for (var j:Number = 0; j != _mainTimeline.NUM_BLOCKS_X; j++)							{								if (this.grid[0][j] > 0)//0								{									//trace("progressGame stacked");									this.gameState = "stacked";									clearGrid();									return;								}							}														for (var k:Number = 0; k < _mainTimeline.NUM_BLOCKS_Y; k++)							{								if (isLineFull(k))								{									//trace("progressGame eliminatingLine");									this.fullLine = k;									this.gameState = "eliminatingLine";									//									var snd_block_row_destroy:block_row_destroy = new block_row_destroy();									snd_block_row_destroy.play();									break;								}							}							if(this.fullLine == -1)							{								//trace("progressGame land");								var snd_block_land:block_land = new block_land();								snd_block_land.play();								createNewFigure();							}							//this.currentFigure.destroy();							//delete this.currentFigure;						}						else						{							//trace("progressGame move down - end else");							move("down", false);						}						this.lastTime = currentTime;					}				}				//				if (this.gameState == "eliminatingLine")				{					if (animateLine(this.fullLine))					{						for (var l:Number = 0; l < _mainTimeline.NUM_BLOCKS_X; l++)						{							//trace("TileGrid - eliminatingLine: "+this.grid[this.fullLine][l]);							//							this.grid[this.fullLine][l] = 0;							Game.playerScore.addScore(100);						}						shiftLines(this.fullLine);						this.gameState = "normal";						this.fullLine = -1;					}				}				draw();			}						// Moves this.currentFigure.			public function move(dir:String, moveTest:Boolean):Boolean			{				try{					//if (this.currentFigure == undefined)					if (this.currentFigure == null)					{						////trace("this.currentFigure == null, returning false");						return false;					}										if (moveTest)					{						// Check if figure will leave grid.						if (!this.currentFigure.move(dir, true))						{							////trace("!this.currentFigure.move(dir, true), returning false");							return false;						}						else						{							var tmp:TileFigure = new TileFigure(this._mainTimeline);							tmp.create(this.currentFigure.currentShape);														for (var i:Number = 0; i < this.currentFigure.blocks.length; i++)							{								tmp.getBlockByIndex(i).x = this.currentFigure.getBlockByIndex(i).x;								tmp.getBlockByIndex(i).y = this.currentFigure.getBlockByIndex(i).y;							}														tmp.move(dir, false);														var allGood:Boolean = true;							for (var j:Number = 0; j < tmp.blocks.length; j++)							{								var blockAtX:Number = tmp.getBlockByIndex(j).x;								var blockAtY:Number = tmp.getBlockByIndex(j).y;																//if (this.currentFigure.getBlock(blockAtX, blockAtY) == undefined)								if (this.currentFigure.getBlock(blockAtX, blockAtY) == null)								{									if (this.grid[blockAtY][blockAtX] > 0)									{										////trace("this.grid[blockAtY][blockAtX] > 0, returning false");										return false;									}								}							}														//delete tmp;							tmp = null;						}					}					else					{						mapFigure(this.currentFigure, false);						this.currentFigure.move(dir, false);						mapFigure(this.currentFigure, true);					}					////trace("end, returning true");					return true;				}catch(e:Error){					//A term is undefined and has no properties.					//null - not ready to move yet force true					return true;				}			}						// Drops block to bottom of game grid.			public function drop()			{				//this.forcedDrop = true;				//progressGame();				if (this.gameState != "dropping") {					this.gameState = "dropping";					//this.dropInterval = setInterval(this, "dropFigureDown", 10);					this.dropInterval = setInterval(this.dropFigureDown, 10);				}			}						private function dropFigureDown()			{				if(_mainTimeline.stopGame){					clearInterval(this.dropInterval);				}				//				if (move("down", true))				{					move("down", false);					draw();				}				else				{					clearInterval(this.dropInterval);					this.gameState = "normal";					Game.shake(_mainTimeline);					if (_mainTimeline.mainAudioLoopStarted == false) {						_mainTimeline.chan_menuLoop.stop();						//						_mainTimeline.chan_game_loop = _mainTimeline.snd_game_loop.play(0,int.MAX_VALUE);						_mainTimeline.mainAudioLoopStarted = true;					}					var s:block_bash = new block_bash();					s.play();					this.dropInterval = undefined;				}			}			// Rotates this.currentFigure.			public function rotate(moveTest:Boolean):Boolean			{				//trace("TileGrid.rotate("+moveTest+"); called");				try{					if (this.currentFigure == null)					{						return false;					}										if (moveTest)					{						if (!this.currentFigure.rotate(true))						{							return false;						}												var tmp:TileFigure = new TileFigure(this._mainTimeline);						tmp.create(this.currentFigure.currentShape);												for (var i:Number = 0; i < this.currentFigure.blocks.length; i++)						{							tmp.getBlockByIndex(i).x = this.currentFigure.getBlockByIndex(i).x;							tmp.getBlockByIndex(i).y = this.currentFigure.getBlockByIndex(i).y;						}												tmp.rotate(false);												for (var j:Number = 0; j < tmp.blocks.length; j++)						{							var blockAtX:Number = tmp.getBlockByIndex(j).x;							var blockAtY:Number = tmp.getBlockByIndex(j).y;														//if (this.currentFigure.getBlock(blockAtX, blockAtY) == undefined)							if (this.currentFigure.getBlock(blockAtX, blockAtY) == null)							{								if (this.grid[blockAtY][blockAtX] > 0)								{									return false;								}							}						}					}					else					{						var snd_rotate:block_rotate = new block_rotate();						snd_rotate.play();						this.mapFigure(this.currentFigure, false);						this.currentFigure.rotate(false);						this.mapFigure(this.currentFigure, true);					}											return true;				}catch(e:Error){					//A term is undefined and has no properties.					//null - not ready to move yet force true					return true;				}			}						// Maps Figure instance to grid.			private function mapFigure(figure:TileFigure, assign:Boolean)			{				//trace("TileGrid.mapFigure("+figure+", "+assign+"); called.");														for (var i:Number = 0; i < figure.blocks.length; i++)				{					if (assign)					{						//if (figure.getBlockByIndex(i) != undefined)						if (figure.getBlockByIndex(i) != null)// && (this.grid[figure.getBlockByIndex(i)]!=undefined))						{							//							try{								this.grid[figure.getBlockByIndex(i).y][figure.getBlockByIndex(i).x] = figure.getBlockByIndex(i).frame;							}catch(e:Error){								//null							}							/*//trace("TileGrid.mapFigure.frame: "+figure.getBlockByIndex(i).frame);*/						}					}					else					{						//if (figure.getBlockByIndex(i) != undefined)						if (figure.getBlockByIndex(i) != null)						{							try{								this.grid[figure.getBlockByIndex(i).y][figure.getBlockByIndex(i).x] = 0;							}catch(e:Error){								//null							}						}					}				}				draw();			}						// Creates new random Figure instance.			public function createNewFigure()			{				//this._mainTimeline				var shapes = new Array("i", "o", "s", "z", "l", "j", "t", "wtf", "wtf", "wtf"); //var shapes = new Array("i", "o", "s", "z", "l", "j", "t", "wtf");				//var shapes = new Array("i","f1","f2","j","l","p1","p2","s1","s2","t","u","v","w","x","y1","y2","z1","z2"); //				var figure:TileFigure = new TileFigure(this._mainTimeline);								var ran:Number = Math.floor(Math.random() * (Game.randomNumber(shapes.length - 1, shapes.length)));				var randomShape = shapes[ran];				figure.create(randomShape);								this.currentFigure = figure;				//trace("createNewFigure: "+randomShape);				mapFigure(this.currentFigure, true);				Game.resetSpeed();			}						// Checks if full row is present in grid.			private function isLineFull(line:Number)			{				////trace("TileGrid.isLineFull(line:Number) called");				if (line < 0) return false;								for (var i:Number = _mainTimeline.GRID_START_X; i != _mainTimeline.GRID_END_X; i++)				{					if (this.grid[line][i] == 0)					{						return false;					}				}				return true;			}			// Shifts all lines down by 1 row.			private function shiftLines(line:Number)			{				//trace("shiftLines("+line+"); called");				for (var i:Number = line; i != -1; i--)				{					for (var j:Number = 0; j != _mainTimeline.NUM_BLOCKS_X; j++)					{						if (i == 0) return; // Can't shift lines above 0 down.												this.grid[i][j] = this.grid[i - 1][j];						this.grid[i - 1][j] = 0;					}				}			}						// Animates destruction of a full line.			private function animateLine(line:Number):Boolean			{				//trace("TileGrid.animateLine("+line+"); called - Animate destruction of a full line.");				var d:Debris = new Debris(this._mainTimeline);//this._mainTimeline is new				var i:Number = 0;				var intrvl:Number = -1;				d.symbol = "rubble";				///*				function explodeBlock()				{						//						//trace("<<TileGrid::animateLine>> Animating \"block" + i + "_" + line + "\"");						var mc:MovieClip = this.parentMC.getChildByName("block" + i + "_" + line) as MovieClip;						//if (mc == undefined) 						//if (mc == null) //						{//							//trace("<<TileGrid::animateLine[383]>> Done animating line.");//							clearInterval(intrvl);//							return;//						}						//trace("<<TileGrid::animateLine[387]>> Animating " + mc + ".");						d.spawn(mc.x, mc.y, 1);						i++;					}catch(e:Error){						//trace("<<TileGrid::animateLine[383]>> Done animating line, or returned null.");						clearInterval(intrvl);						return;						//null					}				}				intrvl = setInterval(explodeBlock, 300);*/				///* Remove *		//		for (var i:Number = 0; i < _global.NUM_BLOCKS_X; i++)		//		{		//			//trace("<<TileGrid::animateLine>> Spawning debris from " + this.parentMC["block" + line + "_" + i]._x);		//			d.spawn(this.parentMC["block" + line + "_" + i]._x, this.parentMC["block" + line + "_" + i]._y, 2);		//		}		//						return true;			}						// Updates MovieClips based on grid.			public function draw()			{				////trace("TileGrid.draw() called");				for (var i:Number = 0; i < _mainTimeline.NUM_BLOCKS_Y; i++)				{					for (var j:Number = 0; j < _mainTimeline.NUM_BLOCKS_X; j++)					{						//if(this.grid[i][j]!=undefined) is new - some return null						//if(this.grid[i][j]!=undefined){							try{								if (this.grid[i][j] > 0)								{									var block_if:MovieClip = this.parentMC.getChildByName("block" + i + "_" + j) as MovieClip;									block_if.gotoAndStop(this.grid[i][j]);									//this.parentMC["block" + i + "_" + j].gotoAndStop(this.grid[i][j]);								}								else								{									var block_else:MovieClip = this.parentMC.getChildByName("block" + i + "_" + j) as MovieClip;									block_else.gotoAndStop(1);									//this.parentMC["block" + i + "_" + j].gotoAndStop(1);								}							}catch(e:Error){								//null							}						//};					}				}			}						/**			* Clears the grid.			*/			private function clearGrid()			{				//trace("TileGrid.clearGrid(); called");				var d:Debris = new Debris(_mainTimeline); //this._mainTimeline is new				d.symbol = "rubble";				//				try{					for (var yi:Number = 0; yi <= _mainTimeline.NUM_BLOCKS_Y; yi++)					{						for (var xi:Number = _mainTimeline.GRID_START_X; xi <= _mainTimeline.GRID_END_X; xi++)						{							if (this.grid[yi][xi] > 0)							{								var block_xi:MovieClip = this.parentMC.getChildByName("block" + yi + "_" + xi) as MovieClip;								var block_yi:MovieClip = this.parentMC.getChildByName("block" + yi + "_" + xi) as MovieClip;								d.spawn(block_xi.x, block_yi.y, 1, "rubble");								this.grid[yi][xi] = 0;								//							}						}					}				}catch(e:Error){					//returned null				}				//				var snd_colapse:row_collapse = new row_collapse();				snd_colapse.play();				//				this.draw();				this.gameState = "normal";				Game.shake(_mainTimeline);//was root				Game.shake(_mainTimeline.mc_cityscape, 2);				Game.shake(_mainTimeline.mc_cityscape2, 4);				Game.playerScore.takeScore(500);			}						/**			* (Deprecated; do not use!) Returns true or false depending on whether a cell is free.			* @param	cx	X coordinate of cell.			* @param	cy	Y coordinate of cell.			* @return	True if cell has a block in it, or false otherwise.			*/			public function isFull(cx:Number, cy:Number):Boolean			{				if (Game.tileGrid.grid[cy][cx] > 0 && Game.tileGrid.grid[cy][cx] != undefined)					return true;				else if (Game.tileGrid.grid[cy][cx] == 0 && Game.tileGrid.grid[cy][cx] != undefined)					return false;			}	}}